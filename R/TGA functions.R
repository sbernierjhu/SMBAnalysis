#'TGA file header loader - binary
#'
#'This function loads into memory the header of a binary file generated by a TA SDT Q600 TGA-DSC.
#'
#'TA SDT Q600 TGA-DSC files typically end in .001, .002, or similar. It may be applicable to other binary files with a header followed by numeric data, but this is untested. The "\f" character is used to detect the end of the header and start of the data.
#'
#' @param filename String name of the file to open. If the file is not stored in your current working directory, be sure to include the full path to the file.
#' @returns String vector containing all the header info.
LoadTGAHeader <- function(filename){
  binaryfile = file(filename,"rb")
  header <- vector()
  repeat{
    line <- readLines(binaryfile,n=1,skipNul = TRUE)
    if(str_detect(line, "\f") == TRUE){
      break}
    header <- c(header,line)
  }
  header <- header[nzchar(header)]
  header <- iconv(header, from = "ISO-8859-1", to = "UTF-8")
  return(header)
}

#'TGA file header loader - text files
#'
#'This function loads into memory the header of a text file generated by TA Universal Analysis based on binary file from a TA SDT Q600 TGA-DSC.
#'
#'Exported TA SDT Q600 TGA-DSC files end in .txt but their contents may vary depending on what the Universal Analysis user selected during export. The "StartOfData" phrase is used to detect the end of the header and start of the data.
#'
#' @param filename String name of the file to open. If the file is not stored in your current working directory, be sure to include the full path to the file.
#' @returns String vector containing all the header info.
LoadTGAHeaderTxt <- function(filename){
  x <- 1L
  line <- "initial"
  header <- c()
  while (!grepl( "StartOfData", line )){
    line <- read_lines(filename, skip = x - 1L, n_max = 1)
    header <- c(header,line)
    x <- x + 1L
  }
  header <- iconv(header, from = "ISO-8859-1", to = "UTF-8")
  return(header)
}

#'TGA data loader - binary
#'
#'This function loads into memory the data contained in a binary file generated by a TA SDT Q600 TGA-DSC.
#'
#'TA SDT Q600 TGA-DSC files typically end in .001, .002, or similar. It may be applicable to other binary files with a header followed by numeric data, but this is untested. The "\f" character is used to detect the end of the header and start of the data.
#'
#' @param filename String name of the file to open. If the file is not stored in your current working directory, be sure to include the full path to the file.
#' @param densedata Boolean for whether to load all the data ('TRUE') or 1/5 data points ('FALSE'). The TA Univeral Analysis program only loads 1/5 data points from the original binary file by default, so to reproduce a .txt file from this program (or to reduce the memory used by R), you should set this to 'FALSE'.
#' @param masspercent Boolean for whether to convert mass data into weight percent data. If 'TRUE', both columns are saved, slightly increasing memory usage.
#' @returns Dataframe containing all columns in the datafile, plus optionally a weight pecent column.
LoadTGAData <- function(filename,densedata=TRUE,masspercent=TRUE){
  binaryfile = file(filename,"rb")
  toread <- round(file.info(filename)$size/4)
  header <- vector()
  x<--1
  repeat{
    line <- readLines(binaryfile,n=1,skipNul = TRUE)
    if(str_detect(line, "\f") == TRUE){
      break}
    header <- c(header,line)
    x <- x+1
  }
  header <- header[nzchar(header)]
  header <- iconv(header, from = "ISO-8859-1", to = "UTF-8")
  y <- as.numeric(sub("Nsig ", "", header[grepl("Nsig", header)]))
  names <- vector(mode="character")
  for (signal in 1:y){
    name <- sub(paste("Sig",signal," ",sep=""), "", header[grepl(paste("Sig",signal,sep=""), header)])
    names <- c(names, name)
  }
  binaryfile = file(filename,"rb")
  readLines(binaryfile,n=x,skipNul = TRUE)
  readBin(binaryfile, "raw", n=5,size=1,endian = 'little')
  allvalues <- readBin(binaryfile, "double", n=toread,size = 4, signed=TRUE,endian = 'little')
  close(binaryfile)
  endofdata<--1+which(allvalues[seq(1, length(allvalues), 7)]==-1)
  futuredf <- vector("list", y)
  for (i in 1:y){
    futuredf[[i]] <- allvalues[seq(i, length(allvalues), y)][1:endofdata]
  }
  df<-as.data.frame(do.call(cbind, futuredf))
  colnames(df) <- names
  if (masspercent==TRUE){
    weightdata <- df[["Weight (mg)"]]
    newcol <- (weightdata/weightdata[[1]])*100
    df <- cbind(df,newcol)
    names(df)[length(names(df))]<-"Relative Weight (%)"
  }
  if (densedata==FALSE){
    firstrow <- df[1,]
    df <- df[4:nrow(df),]
    df <- df %>% filter(row_number() %% 5 == 1)
    df <- rbind(firstrow,df)
  }
  return(df)
}

#'TGA data loader - text files
#'
#'This function loads into memory the data contained in a text file generated by TA Universal Analysis based on binary file from a TA SDT Q600 TGA-DSC.
#'
#'Exported TA SDT Q600 TGA-DSC files end in .txt but their contents may vary depending on what the Universal Analysis user selected during export. The "StartOfData" phrase is used to detect the end of the header and start of the data.
#'
#' @param filename String name of the file to open. If the file is not stored in your current working directory, be sure to include the full path to the file.
#' @param masspercent Boolean for whether to convert mass data into weight percent data. If 'TRUE', both columns are saved, slightly increasing memory usage.
#' @returns Dataframe containing all columns in the datafile, plus optionally a weight pecent column.
LoadTGADataTxt <- function(filename,masspercent=TRUE){
  x <- 1L
  line <- "initial"
  header <- c()
  while (!grepl( "StartOfData", line )){
    line <- read_lines(filename, skip = x - 1L, n_max = 1)
    header <- c(header,line)
    x <- x + 1L
  }
  header <- iconv(header, from = "ISO-8859-1", to = "UTF-8")
  data <- read.delim(filename,header = FALSE,sep = "",na.strings = "",stringsAsFactors = TRUE,
                     skip = x)
  y <- as.numeric(sub("Nsig\t", "", header[grepl("Nsig", header)]))
  names <- vector(mode="character")
  for (signal in 1:y){
    name <- sub(paste("Sig",signal,"\t",sep=""), "", header[grepl(paste("Sig",signal,sep=""), header)])
    names <- c(names, name)
  }
  colnames(data) <- names
  data <- data %>% filter(row_number() <= n()-1)
  if (masspercent==TRUE){
    weightdata <- data[["Weight (mg)"]]
    newcol <- (weightdata/weightdata[[1]])*100
    data <- cbind(data,newcol)
    names(data)[length(names(data))]<-"Relative Weight (%)"
  }
  return(data)
}

#'Convert Mass to Mass Percent
#'
#'This function calculates mass percent given a column of mass data. The first data point is assumed to be 100%.
#'
#' @param dataframe Dataframe containing mass data.
#' @param column  String name of column in the dataframe containing the mass data.
#' @param outputname String name of new column to create for the mass percent data.
#' @returns Dataframe containing all its original columns plus new column appended to the end.
ConvertToMassPercent <- function(dataframe,column="Weight (mg)",outputname="Relative Weight (%)"){
  weightdata <- dataframe[[column]]
  newcol <- (weightdata/weightdata[[1]])*100
  data <- cbind(dataframe,newcol)
  names(data)[length(names(data))]<-outputname
  return(data)
}


#'Three axis plot maker
#'
#'This function generates a plot with three scatterplots of data sharing an independent variable. These plots are commonly made by TA Universal Analysis but may be more generally applicable.
#'
#' @param dataframe Dataframe containing data.
#' @param title String to be used as plot title
#' @param colorpalette Palette of colors to be used for the first, second, and third lines in the plot. See ?palette for examples. Your own palette can be defined using c("color1","color2","color3")
#' @param x  String name of column in the dataframe containing the independent variable.
#' @param y Vector of strings containing the names of columns to be used as the 3 dependent variables.
#' @param width width of output image
#' @param height height of output image
TGA3AxisPlot <- function(dataframe,title="Placeholder title",colorpalette="Dark2",x="Time (min)",
                         y=list("Temperature (°C)","Weight (mg)","Heat Flow (mW)"),width=8,height=6){
  dev.new(width=width,height=height,noRStudioGD = TRUE)
  palette(colorpalette);
  y1 <- y[[1]]
  y2 <- y[[2]]
  y3 <- y[[3]]
  par(oma = c(0, 0, 0, 2),mgp=c(2,0.75, 0))
  plot(dataframe[[x]], dataframe[[y1]], yaxt = "n", xlab = x, main="",
       ylab = y[[1]],pch=0,cex=0.5)
  axis(at = pretty(dataframe[[y1]]), side = 2,lwd=1.5)
  title(main=title, line=1, cex.lab=1.2,mgp=c(1,4,0))
  par(new = TRUE,mgp=c(0,1, -0.75),col.axis=2 )
  plot(dataframe[[x]], dataframe[[y2]], axes = FALSE, col = 2, xlab = "", ylab = "",col.lab=2,
       pch=1,cex=0.5)
  axis(at = pretty(dataframe[[y2]]), side = 4, line = 0,
       col = 2, tcl=-0.75, ,lwd=1.5)
  mtext(y[[2]], side = 4,line=2,col=2)
  par(new = TRUE,mgp=c(0,-2, -1.4),col.axis=3  )
  plot(dataframe[[x]], dataframe[[y3]], axes = FALSE, col = 3, xlab = "", ylab = "",
       pch=5,cex=0.3)
  axis(at = pretty(dataframe[[y3]]), side = 4, line = 0,
       col = 3,tcl=0.75,lwd=1.5)
  mtext(y[[3]], side = 4,line=-3.25,col=3)
}


#'Two-axis plot maker
#'
#'This function generates a plot with two scatterplots of data sharing an independent variable. These plots are commonly made by TA Universal Analysis but may be more generally applicable.
#'
#' @param dataframe Dataframe containing data.
#' @param title String to be used as plot title
#' @param colorpalette Palette of colors to be used for the first and second lines in the plot. See ?palette for examples. Your own palette can be defined using c("color1","color2")
#' @param x  String name of column in the dataframe containing the independent variable.
#' @param y Vector of strings containing the names of columns to be used as the 2 dependent variables.
#' #' @param width width of output image
#' @param height height of output image
TGA2AxisPlot <- function(dataframe,title="Placeholder title",colorpalette="Dark2",x="Time (min)",
                         y=list("Temperature (°C)","Weight (mg)"),width=8,height=6){
  dev.new(width=width,height=height,noRStudioGD = TRUE)
  palette(colorpalette);
  y1 <- y[[1]]
  y2 <- y[[2]]
  par(oma = c(0, 0, 0, 2),mgp=c(2,0.75, 0))
  plot(dataframe[[x]], dataframe[[y1]], yaxt = "n", xlab = x, main="",
       ylab = y[[1]],pch=0,cex=0.5)
  axis(at = pretty(dataframe[[y1]]), side = 2,lwd=1.5)
  title(main=title, line=1, cex.lab=1.2,mgp=c(1,4,0))
  par(new = TRUE,mgp=c(0,1, -0.75),col.axis=2 )
  plot(dataframe[[x]], dataframe[[y2]], axes = FALSE, col = 2, xlab = "", ylab = "",col.lab=2,
       pch=1,cex=0.5)
  axis(at = pretty(dataframe[[y2]]), side = 4, line = 0,
       col = 2, tcl=-0.75, ,lwd=1.5)
  mtext(y[[2]], side = 4,line=2,col=2)
}
