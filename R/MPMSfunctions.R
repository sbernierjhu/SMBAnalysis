#'MPMS data loader
#'
#'This function loads in data from a .dat file generated by a Quantum Design MPMS 3.
#'
#'The function will also print a warning message if a quick check of the DC Moment goodness of fit indicates a potential problem with the voltage fitting. It is good practice to review this data independently to confirm the validity of your moment results. See https://qdusa.com/siteDocs/appNotes/1500-018.pdf for more info.
#'
#' @param folder String describing folder containing the datafile
#' @param filename String of datafile name, should end in .dat
#' @param removenames Vector of strings to filter out of column names, i.e. words to search for in column names; these columns will not be loaded. Example: removenames = c("Comment","AC") will not load the Comment column nor the columns for AC Moment (emu), AC M. Std Err. (emu), AC Phase (deg), etc. etc. The default is to remove columns describing instrument status and columns used to calculate observables (with the exception of the calculated straw center position). To **not** remove any columns, input an empty vector c().
#' @param preerveempty Boolean for whether to preserve columns which contain NO data.
#' @param relativetime Boolean for whether to rescale the time stamp to begin at 0 and count from there, creating a new column called 'AbsTimeSec'. Default is to instead report the MPMS measure of absolute time. To remove the old column of absolute time, add "Stamp" or similar to the vector in 'removenames'.
#' @returns Dataframe containing selected columns in the .dat file.
OpenMPMSData <- function(folder=getwd(),filename=NULL,removenames=c("Action","Range","Min","Max","Pressure","Number","code","Motor","Stat","Average","Scan","Chamber","Drift","Position","Fit"),preserveempty=FALSE,relativetime=FALSE){
  if(is.null(filename))
    stop("Please input your filename")
  fullfilepath <- paste(folder, filename, sep = "/")
  originaldata <- read.delim(fullfilepath,
                             header = TRUE,
                             sep = ",",
                             na.strings = "",
                             stringsAsFactors = TRUE,
                             skip = 44)
  moddata <- originaldata
  names(moddata) <- gsub(x = names(moddata),
                         pattern = "\\.",
                         replacement = "")
  fixed<-mean(moddata$DCFixedFit)
  if (is.na(fixed)){
    fixed<-mean(moddata$DCFixedFit,na.rm = TRUE)
    print("Warning: Your fixed center data contains empty rows.")
  }
  free<-mean(moddata$DCFreeFit)
  if (is.na(free)){
    free<-mean(moddata$DCFreeFit,na.rm = TRUE)
    print("Warning: Your free center data contains empty rows.")
  }
  if(fixed <= 0.9){
    print(paste("Warning: The average of your DC Fixed Data GOF is",round(fixed,4),"It is recommended to review the raw voltage curves and the calculated free center position. See https://qdusa.com/siteDocs/appNotes/1500-018.pdf for more info."))
  }
  if(free <= 0.9){
    print(paste("Warning: The average of your DC Free Data GOF is",round(free,4),"It is recommended to review the raw voltage curves especially if you see sudden jumps in magnetization data. See https://qdusa.com/siteDocs/appNotes/1500-018.pdf for more info."))
  }
  if(relativetime == TRUE){
    AbsTimesec<-moddata$TimeStampsec-moddata$TimeStampsec[1]
    moddata<-cbind(moddata,AbsTimesec)
  }
  if(preserveempty == FALSE){
  moddata <- Filter(function(x)!all(is.na(x)), moddata)}
  if(!is.vector(removenames)){
    return(moddata)
  }else{
    moddata <- moddata %>%
      select(-contains(removenames))
  return(moddata)
  }
}

#'MPMS sample mass parser
#'
#'This function reads the header from a .dat file generated by a Quantum Design MPMS 3 and returns the user-input sample mass
#'
#' @param folder String describing folder containing the datafile
#' @param filename String of datafile name, should end in .dat
#' @returns Numeric sample mass in grams (not milligrams)
ReadMPMSSampleMass <- function(folder,filename){
  fullfilepath <- paste(folder, filename, sep = "/")
  as.numeric(str_extract(read.table(fullfilepath, nrows=1, skip=27, sep = "="), "(?<=INFO,)[[:graph:]]+(?=,SAMPLE_MASS)" ))*10^-3}

#'DC [Molar/Mass] Magnetic susceptibility calculator
#'
#'This function reads columns of data for applied field strength and magnetization and calculates the standard, molar, or mass magnetic susceptibility assuming M=Chi*H (linear relationship valid for low fields in DC magnetization measurements).
#'
#'If data were input in consistent units - either all cgs (emu for magnetization and Oe for field H) or all SI (A/m or J/Tm^3 for magnetization and A/m for field H) - then the units output are detailed below, and depend on which type of magnetic susceptibility you have chosen to calculate - standard, mass susceptibility, or molar susceptibility.
#'
#'In the event you want susceptibility, not molar/mass susceptibility, set both 'Mass' and 'MolarMass' to 1. The resulting output value will then be unitless (if using cgs units, the output may also be represented as emu/cm^3, which is actually still unitless).
#'
#'If you would like mass susceptibility, set 'MolarMass' to 1. The output units of this function for mass susceptibility are m^3/g (SI) and emu/g (cgs). 1 emu/g (cgs) = 4*pi*10^-3 m^3/kg (SI)
#'
#'If you would like molar susceptibility, set neither 'Mass' nor 'MolarMass' to 1. The output units of this function for molar susceptibility are m^3/mol (SI) and emu/mol (cgs). 1 emu/mol (cgs) = 4*pi*10^-6 m^3/mol (SI)
#'
#' @param dataframe Name of dataframe containing columns of data
#' @param H String name of column in dataframe containing applied magnetic field data (take note of your units; this function does no conversion)
#' @param M String name of column in dataframe containing sample magnetization data (take note of your units; this function does no conversion)
#' @param MolarMass Numeric molar mass of sample (assumed in amu)
#' @param Mass Numeric mass of sample (assumed in grams)
#' @param CalcInv By default, the function also returns 1/susceptibility unless this parameter is set to 'FALSE'
#' @returns Input dataframe with magnetic susceptibility ("Susc") and, optionally, inverse susceptibility ("Chiinv") columns attached at end
CalculateSusceptibility <- function(dataframe,H="MagneticFieldOe",M="DCMomentFreeCtremu",MolarMass=1,Mass=1,CalcInv=TRUE){
  susc <- (dataframe[[M]]/dataframe[[H]])*(MolarMass/Mass)
  if (CalcInv == TRUE){
  chiinv <- 1/susc
  dataframe <- cbind(dataframe,susc,chiinv)}else{
    dataframe <- cbind(dataframe,susc)
  }
  return(dataframe)
}

#'AC Magnetic susceptibility calculator
#'
#'This function reads columns of data for applied field strength and magnetization and calculates the molar magnetic susceptibility chi=dM/dH.
#'
#' @param dataframe Name of dataframe containing columns of data
#' @param H String name of column in dataframe containing applied magnetic field data (take note of your units; this function does no conversion)
#' @param M String name of column in dataframe containing sample magnetization data (take note of your units; this function does no conversion)
#' @param MolarMass Numeric molar mass of sample (assumed in amu)
#' @param Mass Numeric mass of sample (assumed in grams)
#' @param CalcInv By default, the function also returns 1/susceptibility unless this parameter is set to 'FALSE'
#' @returns Input dataframe with magnetic susceptibility ("Susc") and, optionally, inverse susceptibility ("Chiinv") columns attached at end
CalculateACSusceptibility <- function(dataframe,H="MagneticFieldOe",M="DCMomentFreeCtremu",MolarMass=1,Mass=1,CalcInv=TRUE){
  Field<-dataframe[[H]]
  Mag<-dataframe[[M]]
  if (length(Mag) != length(Field)) {
    stop('M and H vectors must have equal length')
  }
  n <- length(Field)
  susc <- vector(length = n)
  susc[1] <- NA
  for (i in 2:n) {
    susc[i] <- (Mag[i] - Mag[i-1]) / (Field[i] - Field[i-1])
  }
  susc<-susc*(MolarMass/Mass)
  if (CalcInv == TRUE){
    chiinv <- 1/susc
    dataframe <- cbind(dataframe,susc,chiinv)}else{
      dataframe <- cbind(dataframe,susc)
    }
  return(dataframe)
}

#'Modified Curie-Weiss analysis Chi-Naught guesser
#'
#'This function uses a binary search algorithm to guess the chi0 value required to make "almost linear" magnetic susceptibility data linear and thus enable Curie-Weiss analysis.
#'
#'See https://doi.org/10.1038/s42005-022-00853-y for a justification of the binary search technique.
#'
#' @param Tstart The temperature which should be the lower bound of the Curie-Weiss analysis
#' @param Tend The temperature which should be the upper bound of the Curie-Weiss analysis
#' @param dataframe Name of dataframe containing columns of data. Note that if your data contains the same temperatures repeated, you should use dataframe[x:y,] to select the points x-y to use.
#' @param Tcolumn String name of column in dataframe containing temperature data
#' @param Susccolumn String name of column in dataframe containing susceptibility data
#' @param initialguess Numeric initial guess of the chi0 value. Linear data should have chi0=0. Note that a wildly off guess can cause this function to fail.
#' @param guessforme Boolean for whether to do the binary search for an improved chi0 value. If 'FALSE', this function returns the R^2 value of data and whether it "thinks" your chi0 guess can be improved.
#' @param limitto Options are "POS" for positive chi0 (concave data) and "NEG" for negative chi0 (convex data)
#' @param perturb Numeric value for the width of the window to search with the binary search algorithm. A typical value on first run is 1.5, resulting in a search window of -1.5*guess to 1.5*guess. After you get close to a good chi0, reduce the factor to 1.05, 1.005, or similar to maximize the number of sig figs in your answer.
#' @returns The numeric value of the best chi0 acheived by the function. Printed text comments guide the user in using the function to refine this value.
ChiNaughtGuesser <- function(Tstart=0,Tend=300,dataframe,Tcolumn="TemperatureK",Susccolumn="susc",initialguess=0,guessforme=TRUE,limitto="POS",perturb=1.1){
  datarange <- dataframe[dataframe[[Tcolumn]] >= Tstart & dataframe[[Tcolumn]] <= Tend,]
  tempdata <- datarange[[Tcolumn]]
  suscdata <- datarange[[Susccolumn]]
  Rtestplain<-summary(lm(1/(suscdata) ~ tempdata))$r.squared
  Rtestinitial<-summary(lm(1/(suscdata-initialguess) ~ tempdata))$r.squared
  print(paste("Your initial guess yields an R^2 of",signif(Rtestinitial,4)))
  print(paste("Compared to a raw data R^2 of",signif(Rtestplain,4)))
  curvature <- check_curve(tempdata,suscdata)[[1]]
  if(grepl("_",curvature) == TRUE){
    print("Please check your data limits; multiple curvatures detected")}
  else{
    if(curvature=="convex"){limitto <- "NEG"}
    if(curvature=="concave"){limitto <- "POS"}}
  if(abs(initialguess) <= 1e-6){
    chi0 <- 0
    print("Recommended to use 0 as your chi0")
  }else{
    if(abs(Rtestplain-Rtestinitial) <= 1e-5){
      chi0 <- initialguess
      print("Recommended to use initial guess as your chi0")
    }else{
      chi0 <- initialguess
      print("Improvement possible")
      if(guessforme == TRUE){
        if(limitto=="POS"){
          chilo <- 0
          chihi <- perturb*abs(chi0)}
        else{
          chilo <- 0-perturb*abs(chi0)
          chihi <- 0}
        Rlo <- summary(lm(1/(suscdata-chilo) ~ tempdata))$r.squared
        Rhi <- summary(lm(1/(suscdata-chihi) ~ tempdata))$r.squared
        while(abs(Rhi-Rlo) >= 1e-5){
          chimid <- (chilo+chihi)/2
          Rmid <- summary(lm(1/(suscdata-chimid) ~ tempdata))$r.squared
          if(Rlo > Rhi){
            chihi <- chimid
            Rhi <- Rmid}
          else{
            chilo <- chimid
            Rlo <- Rmid}}
        chiend <- (chilo+chihi)/2
        Rfinal <- summary(lm(1/(suscdata-chiend) ~ tempdata))$r.squared
        print(paste("The final chi0 has an R^2 of",signif(Rfinal,4)))
        if(Rfinal < 0.9987){
          if(Rfinal < Rtestinitial | Rfinal < Rtestplain){
            print("Improvement failed. Try smaller perturbation window.")}
          else{
            print("But you can run this again with the new value to improve things!")
            chi0 <- chiend}
        }
        else{print("Doesn't get much better than this!")
          chi0 <- chiend}}
    }}
  return(chi0)}

#'Curie-Weiss fitting function
#'
#'This function performs a linear fit to magnetic susceptibility data and plots it along with various fit parameters.
#'
#' @param Tstart The temperature which should be the lower bound of the Curie-Weiss analysis
#' @param Tend The temperature which should be the upper bound of the Curie-Weiss analysis
#' @param material A string describing the material to go in plot titles
#' @param dataframe Name of dataframe containing columns of data. Note that if your data contains the same temperatures repeated, you should use dataframe[x:y,] to select the points x-y to use.
#' @param Tcolumn String name of column in dataframe containing temperature data
#' @param ChiInvColumn String name of column in dataframe containing inverse susceptibility data
#' @param color Color to plot the data in.
#' @param pubreadyplot Boolean for whether to open a popup window with fit parameters in a text box on top of the plot in the style favored by McQueen Lab for publications.
BasicCurieWeissfit <- function(Tstart=0,Tend=300,material="",dataframe,Tcolumn="TemperatureK",ChiInvcolumn="chiinv",color="darkgray",pubreadyplot=FALSE){
  tempdata <- dataframe[dataframe[[Tcolumn]] >= Tstart & dataframe[[Tcolumn]] <= Tend,][[Tcolumn]]
  chiinvdata <- dataframe[dataframe[[Tcolumn]] >= Tstart & dataframe[[Tcolumn]] <= Tend,][[ChiInvcolumn]]
  Rtest<-cor.test(tempdata, chiinvdata)$estimate
  plot(x = tempdata,
       y=chiinvdata,
       xlab = "Temperature (K)",
       ylab=expression(paste("1/", chi," (mol Oe/emu)")),
       main = paste(material," True Curie-Weiss fit from T =",Tstart,"K to",Tend,"K (has R^2 of",signif(Rtest,4),")"),
       pch=1,
       cex=0.75,
       col=color)
    model <- lm(chiinvdata ~ tempdata, data=dataframe[dataframe[[Tcolumn]] >= Tstart & dataframe[[Tcolumn]] <= Tend,])
    CurieConst <- 1/model$coefficients[[2]]
    CurieTemp <- -1*model$coefficients[[1]]/model$coefficients[[2]]
    abline(model,lwd=3,lty=2,col="black") #Add a regression line
    mtext(paste("Fit results: C:",signif(CurieConst,4),"emu K/mol;","Theta:",signif(CurieTemp,4), "K; R2:",signif(summary(model)$adj.r.squared,4)), side = 3, line = 0, col = "black", cex = 1.2)
    if(pubreadyplot==TRUE){
      print("Generating publication-ready plot in new window")
      tempmin <- as.numeric(min(tempdata))
      heightmax <- as.numeric(max(chiinvdata))
      heightdif <- heightmax-as.numeric(min(chiinvdata))
      dev.new(width=6,height=4.5,noRStudioGD = TRUE)
      plot(x = tempdata,y=chiinvdata, xlab = "Temperature (K)",ylab=expression(paste("1/", chi," (mol Oe/emu)")),
           #main = paste(material,"Curie-Weiss fit from T =",Tstart,"K to",Tend),
           pch=1,cex=0.75,col=color)
      text(x=tempmin, y=heightmax-heightdif*.1, paste("C =",signif(CurieConst,4),"emu K/mol"),pos=4)
      text(x=tempmin, y=heightmax-heightdif*.2, expr(paste(theta["CW"]," = ",!!signif(CurieTemp,4),"K")),pos=4)
      text(x=tempmin, y=heightmax-heightdif*.3, expr(paste("R"^2," = ",!!signif(summary(model)$adj.r.squared,4))),pos=4)
    }
    }

#'Modified Curie-Weiss fitting function
#'
#'This function performs a nonlinear fit to magnetic susceptibility data and plots it along with various fit parameters. See https://doi.org/10.1038/s42005-022-00853-y
#'
#' @param Tstart The temperature which should be the lower bound of the Curie-Weiss analysis
#' @param Tend The temperature which should be the upper bound of the Curie-Weiss analysis
#' @param material A string describing the material to go in plot titles
#' @param dataframe Name of dataframe containing columns of data. Note that if your data contains the same temperatures repeated, you should use dataframe[x:y,] to select the points x-y to use.
#' @param Tcolumn String name of column in dataframe containing temperature data
#' @param Susccolumn String name of column in dataframe containing susceptibility data
#' @param ChiInvColumn String name of column in dataframe containing inverse susceptibility data (used to perform a traditional Curie-Weiss fit)
#' @param chi0guess Numeric initial guess of the chi0 value. Linear data should have chi0=0. Note that a wildly off guess can cause this function to fail.
#' @param Cconstguess Numeric initial guess of the Curie-Weiss parameter value (in units determined by your susceptibility data). Note that a wildly off guess can cause this function to fail.
#' @param thetaCWguess Numeric initial guess of the Curie-Weiss temperature value (in units of your temperature data). This is the y-intercept of your data. Note that a wildly off guess can cause this function to fail.
#' @param dofit Boolean for whether to perform a nonlinear fit. If 'FALSE', a linear fit only is attempted to provide R^2 values (see ?BasicCurieWeissfit)
#' @param color Color to plot the data in.
#' @param pubreadyplot Boolean for whether to open a popup window with fit parameters in a text box on top of the plot in the style favored by McQueen Lab for publications.
AdjustedCurieWeissfit <- function(Tstart=0,Tend=300,material="",dataframe,Tcolumn="TemperatureK",Susccolumn="susc",ChiInvcolumn="chiinv",chi0guess=0,Cconstguess=0.8,thetaCWguess=1000,color="darkgray",dofit=FALSE,pubreadyplot=FALSE){
  ChiNaught <- chi0guess
  datarange <- dataframe[dataframe[[Tcolumn]] >= Tstart & dataframe[[Tcolumn]] <= Tend,]
  tempdata <- datarange[[Tcolumn]]
  chiinvdata <- datarange[[ChiInvcolumn]]
  suscdata <- datarange[[Susccolumn]]
  Rtest<-summary(lm(chiinvdata ~ tempdata))$r.squared
  plot(x = tempdata,
       y=chiinvdata,
       xlab = "Temperature (K)",
       ylab=expression(paste("1/", chi," (mol Oe/emu)")),
       main = paste(material,"Adj. Curie-Weiss fit from T =",Tstart,"-",Tend,"K (raw data;",signif(Rtest,4),"R^2 )"),
       pch=1,
       cex=0.75,
       col=color)
  text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))
  if(dofit == TRUE){
    model <- nls(chiinvdata ~ I((tempdata - theta)/(chi0*(tempdata-theta)+C)),data=datarange, control=nls.control(maxiter = 1000),
                 start = list(chi0=chi0guess,theta = thetaCWguess,C=Cconstguess))
    lines(tempdata,predict(model,newdata = datarange),lwd=2.5,lty=2,col="black")
    CurieConst <- summary(model)$coeff[[3]]
    CurieTemp <- summary(model)$coeff[[2]]
    ChiNaught <- summary(model)$coeff[[1]]
    mtext(paste("Fit results: C:",signif(CurieConst,4),"emu K/mol;","Theta:",signif(CurieTemp,4), "K; Chi0:", signif(ChiNaught,4),"; R2: N/A"), side = 3, line = 0, col = "black", cex = 1.2)
    plot(x = tempdata,
         y=1/(suscdata-ChiNaught),
         xlab = "Temperature (K)",
         ylab=expression(paste("1/", chi,"-",chi[0]," (mol Oe/emu)")),
         main = paste(material,"Adj. Curie-Weiss fit from T =",Tstart,"-",Tend,"K"),
         pch=1,
         cex=0.75,
         col=color)
    linearmodel <- lm(1/(suscdata-ChiNaught) ~ tempdata)
    abline(linearmodel,lwd=2.5,lty=2,col="black")
    CurieConst2 <- 1/linearmodel$coefficients[[2]]
    CurieTemp2 <- -1*linearmodel$coefficients[[1]]/linearmodel$coefficients[[2]]
    mtext(paste("Fit results: C:",signif(CurieConst2,4),"emu K/mol;","Theta:",signif(CurieTemp2,4), "K; R2:",signif(summary(linearmodel)$adj.r.squared,4)), side = 3, line = 0, col = "black", cex = 1.2)
  if(pubreadyplot==TRUE){
    print("Generating publication-ready plot in new window")
    tempmin <- as.numeric(min(tempdata))
    heightmax <- as.numeric(max(1/(suscdata-ChiNaught)))
    heightdif <- heightmax-as.numeric(min(1/(suscdata-ChiNaught)))
    dev.new(width=6,height=4.5,noRStudioGD = TRUE)
    plot(x = tempdata,y=1/(suscdata-ChiNaught), xlab = "Temperature (K)",ylab=expression(paste("1/", chi,"-",chi[0]," (mol Oe/emu)")),
         #main = paste(material,"Adj. Curie-Weiss fit from T = ",Tstart,"-",Tend,"K"),
         pch=1,cex=0.75,col=color)
    abline(linearmodel,lwd=2.5,lty=2,col="black")
    text(tempmin, heightmax-heightdif*.1, expr(paste(chi[0]," = ",!!signif(ChiNaught,4)," mol Oe/emu")),pos=4)
    text(x=tempmin, y=heightmax-heightdif*.2, paste("C =",signif(CurieConst2,4),"emu K/mol"),pos=4)
    text(x=tempmin, y=heightmax-heightdif*.3, expr(paste(theta["CW"]," = ",!!signif(CurieTemp2,4),"K")),pos=4)
    text(x=tempmin, y=heightmax-heightdif*.4, expr(paste("R"^2," = ",!!signif(summary(linearmodel)$adj.r.squared,4))),pos=4)
  }
  }else{
    print("User requests skipped nonlinear fit, using chi0 guess for linear fit")
    plot(x = tempdata,
         y=1/(suscdata-ChiNaught),
         xlab = "Temperature (K)",
         ylab=expression(paste("1/", chi,"-",chi[0]," (mol Oe/emu)")),
         main = paste(material,"Adj. Curie-Weiss fit from",Tstart,"-",Tend,"K"),
         pch=1,
         cex=0.75,
         col=color)
    linearmodel <- lm(1/(suscdata-ChiNaught) ~ tempdata)
    abline(linearmodel,lwd=2.5,lty=2,col="black")
    CurieConst2 <- 1/linearmodel$coefficients[[2]]
    CurieTemp2 <- -1*linearmodel$coefficients[[1]]/linearmodel$coefficients[[2]]
    mtext(paste("Fit results: C:",signif(CurieConst2,4),"emu K/mol;","Theta:",signif(CurieTemp2,4), "K; R2:",signif(summary(linearmodel)$adj.r.squared,4)), side = 3, line = 0, col = "black", cex = 1.2)
  }
  }


#'Inset plot generator
#'
#'This function makes a plot with an inset. The specifics are tailored to viewing magnetic susceptibility data, but it may be more generally applicable.
#'
#' @param dataframe Name of dataframe containing columns of data.
#' @param xcolumn String name of the column in the dataframe to be your independent variable.
#' @param ycolumn String name of the column in the dataframe to be your dependent variable.
#' @param xstart First value in your independent variable list to plot. This is the actual number for the x-axis minimum, not an index.
#' @param xend Last value in your independent variable list to plot. This is the actual number for the x-axis maximum, not an index.
#' @param maintitle String to be the title of your main plot.
#' @param subtitle String to be the title of your inset plot.
#' @param xtitle String to be the title of your x-axis.
#' @param ytitle String to be the title of your y-axis.
#' @param color Color to plot the data in.
PlotWithInset <- function(dataframe,xcolumn="TemperatureK",ycolumn="susc",xstart=0,xend=300,maintitle="",subtitle="",xtitle="Temperature (K)",ytitle="Magnetization (emu)",color="steelblue")
{datarange <- dataframe[dataframe[[xcolumn]] >= xstart & dataframe[[xcolumn]] <= xend,]
xdata <- datarange[[xcolumn]]
ydata <- datarange[[ycolumn]]
  dev.new(width=6,height=4.5,noRStudioGD = TRUE)
  plot(x = dataframe[[xcolumn]],
       y = dataframe[[ycolumn]],
       xlab = xtitle,
       ylab= ytitle,
       main = maintitle,
       pch=1,
       cex=0.75,
       col=color)
  u <- par("usr")
  v <- c(
    grconvertX(u[1:2], "user", "ndc"),
    grconvertY(u[3:4], "user", "ndc")
  )
  v <- c( (v[1]+v[2])/2, v[2], (v[3]+v[4])/2, v[4] )
  par( fig=v, new=TRUE, mar=c(0,1,1.5,1) )
  plot(x = xdata,
       y = ydata,
       xaxt  = "n", main=subtitle,
       cex.main=0.75, cex.axis=0.8,col=color)
  axis(side = 1)
  box()

}
